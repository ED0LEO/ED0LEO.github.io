<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Greek-Themed Dining Philosophers Visualization</title>
    <style>
        body { font-family: Arial, sans-serif; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; margin: 0; background-color: #f0f0f0; }
        #canvas { border: 1px solid #000; margin: 20px 0; }
        #info, #controls, #prediction { text-align: center; margin-bottom: 20px; }
        input { margin: 5px; padding: 5px; }
        button { margin: 10px; padding: 5px 10px; }
    </style>
</head>
<body>
    <div id="info">
        <h2>Greek-Themed Dining Philosophers Simulation</h2>
    </div>
    <div id="controls">
        <input type="number" id="numPhilosophers" placeholder="Number of philosophers" min="1" value="5">
        <input type="number" id="timeToDie" placeholder="Time to die (ms)" min="1000" value="4000">
        <input type="number" id="timeToEat" placeholder="Time to eat (ms)" min="100" value="2000">
        <input type="number" id="timeToSleep" placeholder="Time to sleep (ms)" min="100" value="2000">
        <input type="number" id="numMeals" placeholder="Number of meals (optional)" min="1">
        <br>
        <button onclick="startSimulation()">Start Simulation</button>
        <button id="pauseButton" onclick="togglePause()">Pause</button>
        <button onclick="stepForward()">Step Forward</button>
        <button onclick="stepBackward()">Step Backward</button>
    </div>
    <div id="prediction"></div>
    <canvas id="canvas" width="800" height="800"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let numPhilosophers, timeToDie, timeToEat, timeToSleep, numMeals;
        let tableRadius, philosopherSize, forkLength, forkWidth;
        let philosophers = [];
        let forks = [];
        let globalTime = 0;
        let simulationRunning = false;
        let simulationPaused = false;
        let animationFrameId = null;
        let timeSteps = [];
        let currentStepIndex = -1;

        class Philosopher {
            constructor(id, angle) {
                this.id = id;
                this.angle = angle;
                this.state = 'thinking';
                this.lastEatTime = 0;
                this.leftFork = null;
                this.rightFork = null;
                this.timeElapsed = 0;
                this.stateChangeTime = 0;
                this.mealsEaten = 0;
            }

            draw() {
                const x = canvas.width / 2 + Math.cos(this.angle) * tableRadius;
                const y = canvas.height / 2 + Math.sin(this.angle) * tableRadius;

                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(this.angle + Math.PI / 2);

                // Draw philosopher silhouette
                ctx.fillStyle = this.getColor();
                ctx.beginPath();
                ctx.moveTo(0, -philosopherSize / 2);
                ctx.lineTo(-philosopherSize / 4, -philosopherSize / 4);
                ctx.lineTo(-philosopherSize / 3, philosopherSize / 3);
                ctx.lineTo(philosopherSize / 3, philosopherSize / 3);
                ctx.lineTo(philosopherSize / 4, -philosopherSize / 4);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Draw beard
                ctx.beginPath();
                ctx.moveTo(-philosopherSize / 6, 0);
                ctx.lineTo(0, philosopherSize / 3);
                ctx.lineTo(philosopherSize / 6, 0);
                ctx.stroke();

                // Draw wreath
                ctx.beginPath();
                ctx.arc(0, -philosopherSize / 3, philosopherSize / 6, 0, Math.PI, true);
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();

                this.drawStateIcon(x, y);
                this.drawStats(x, y);
            }

            drawStateIcon(x, y) {
                ctx.fillStyle = 'black';
                ctx.font = `${Math.max(16, 28 - numPhilosophers / 2)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const iconY = y - philosopherSize / 2 - Math.max(10, 20 - numPhilosophers / 2);

                switch (this.state) {
                    case 'thinking': ctx.fillText('ðŸ’¡', x, iconY); break;
                    case 'eating': ctx.fillText('ðŸ', x, iconY); break;
                    case 'sleeping': ctx.fillText('ðŸ’¤', x, iconY); break;
                    case 'dead': ctx.fillText('ðŸ’€', x, iconY); break;
                }
            }

            drawStats(x, y) {
                ctx.font = `${Math.max(10, 14 - numPhilosophers / 4)}px Arial`;
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${(this.timeElapsed / 1000).toFixed(1)}s`, x, y + philosopherSize / 2 + 10);
                ctx.fillText(`Meals: ${this.mealsEaten}`, x, y + philosopherSize / 2 + 25);
            }

            getColor() {
                switch (this.state) {
                    case 'thinking': return '#AED6F1';
                    case 'eating': return '#ABEBC6';
                    case 'sleeping': return '#D7BDE2';
                    default: return '#F1948A';
                }
            }

            update() {
                this.timeElapsed = globalTime - this.lastEatTime;

                if (this.timeElapsed >= timeToDie) {
                    this.state = 'dead';
                    return true;  // Indicate that a philosopher has died
                }

                if (this.state === 'thinking') {
                    this.tryToEat();
                } else if (this.state === 'eating' && globalTime - this.stateChangeTime >= timeToEat) {
                    this.sleep();
                } else if (this.state === 'sleeping' && globalTime - this.stateChangeTime >= timeToSleep) {
                    this.think();
                }

                return false;  // No philosopher has died
            }

            think() {
                this.state = 'thinking';
                this.stateChangeTime = globalTime;
                this.putForks();
            }

            tryToEat() {
                if (numPhilosophers === 1) return; // Cannot eat with only one philosopher

                const leftForkIndex = this.id;
                const rightForkIndex = (this.id - 1 + numPhilosophers) % numPhilosophers;
                const leftFork = forks[leftForkIndex];
                const rightFork = forks[rightForkIndex];

                if (!leftFork.inUse && !rightFork.inUse) {
                    leftFork.pickup(this);
                    rightFork.pickup(this);
                    this.leftFork = leftFork;
                    this.rightFork = rightFork;
                    this.eat();
                }
            }

            eat() {
                this.state = 'eating';
                this.lastEatTime = globalTime;
                this.stateChangeTime = globalTime;
                this.mealsEaten++;
            }

            putForks() {
                if (this.leftFork) this.leftFork.putdown();
                if (this.rightFork) this.rightFork.putdown();
                this.leftFork = null;
                this.rightFork = null;
            }

            sleep() {
                this.state = 'sleeping';
                this.stateChangeTime = globalTime;
                this.putForks();
            }
        }

        class Fork {
            constructor(id, angle) {
                this.id = id;
                this.angle = angle;
                this.inUse = false;
                this.user = null;
            }

            draw() {
                const midX = canvas.width / 2 + Math.cos(this.angle) * tableRadius;
                const midY = canvas.height / 2 + Math.sin(this.angle) * tableRadius;
                
                ctx.save();
                ctx.translate(midX, midY);
                ctx.rotate(this.angle + Math.PI / 2);

                ctx.beginPath();
                ctx.rect(-forkWidth/2, -forkLength/2, forkWidth, forkLength);
                ctx.fillStyle = this.inUse && this.user && this.user.state === 'eating' ? '#E74C3C' : '#7F8C8D';
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1;
                ctx.stroke();

                const tineWidth = forkWidth / 3;
                const tineLength = forkLength / 4;
                for (let i = -1; i <= 1; i++) {
                    ctx.beginPath();
                    ctx.rect(i * tineWidth - tineWidth/2, -forkLength/2 - tineLength, tineWidth, tineLength);
                    ctx.fill();
                    ctx.stroke();
                }

                ctx.restore();

                ctx.fillStyle = 'black';
                ctx.font = `${Math.max(8, 12 - numPhilosophers / 4)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id + 1, midX, midY);

                if (this.inUse && this.user) {
                    this.drawArrow(midX, midY, this.user);
                }
            }

            drawArrow(fromX, fromY, toPhilosopher) {
                const toX = canvas.width / 2 + Math.cos(toPhilosopher.angle) * tableRadius;
                const toY = canvas.height / 2 + Math.sin(toPhilosopher.angle) * tableRadius;

                const headlen = Math.max(5, 10 - numPhilosophers / 5);
                const dx = toX - fromX;
                const dy = toY - fromY;
                const angle = Math.atan2(dy, dx);

                ctx.beginPath();
                ctx.moveTo(fromX, fromY);
                ctx.lineTo(toX, toY);
                ctx.strokeStyle = '#E74C3C';
                ctx.lineWidth = Math.max(1, 2 - numPhilosophers / 20);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(toX, toY);
                ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
                ctx.fillStyle = '#E74C3C';
                ctx.fill();
            }

            pickup(philosopher) {
                this.inUse = true;
                this.user = philosopher;
            }

            putdown() {
                this.inUse = false;
                this.user = null;
            }
        }

        function initializePhilosophersAndForks() {
            philosophers = [];
            forks = [];
            for (let i = 0; i < numPhilosophers; i++) {
                const angle = (i / numPhilosophers) * Math.PI * 2 - Math.PI / 2;
                philosophers.push(new Philosopher(i, angle));
                forks.push(new Fork(i, angle + Math.PI / numPhilosophers));
            }
        }

        function drawTable() {
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, tableRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#F0E68C';
            ctx.fill();
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 10;
            ctx.stroke();
        }

        function update() {
            globalTime += 16;
            let philosopherDied = false;
            philosophers.forEach(p => {
                if (p.update()) {
                    philosopherDied = true;
                }
            });

            if (philosopherDied || (numMeals && philosophers.every(p => p.mealsEaten >= numMeals))) {
                stopSimulation();
            }

            saveTimeStep();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawTable();
            forks.forEach(f => f.draw());
            philosophers.forEach(p => p.draw());
        }

        function gameLoop() {
            if (!simulationRunning || simulationPaused) return;
            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function startSimulation() {
            stopSimulation();
            
            numPhilosophers = parseInt(document.getElementById('numPhilosophers').value) || 5;
            timeToDie = parseInt(document.getElementById('timeToDie').value) || 4000;
            timeToEat = parseInt(document.getElementById('timeToEat').value) || 2000;
            timeToSleep = parseInt(document.getElementById('timeToSleep').value) || 2000;
            numMeals = parseInt(document.getElementById('numMeals').value) || 0;

            tableRadius = Math.min(canvas.width, canvas.height) * 0.35;
            philosopherSize = Math.max(20, tableRadius * 0.36 - numPhilosophers * 2);
            forkLength = Math.max(15, tableRadius * 0.22 - numPhilosophers);
            forkWidth = forkLength * 0.16;

            globalTime = 0;
            simulationRunning = true;
            simulationPaused = false;
            timeSteps = [];
            currentStepIndex = -1;

            initializePhilosophersAndForks();
            updatePrediction();
            gameLoop();
            document.getElementById('pauseButton').textContent = 'Pause';
        }

        function stopSimulation() {
            simulationRunning = false;
            simulationPaused = false;
            if (function stopSimulation() {
            simulationRunning = false;
            simulationPaused = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        }

        function togglePause() {
            simulationPaused = !simulationPaused;
            document.getElementById('pauseButton').textContent = simulationPaused ? 'Resume' : 'Pause';
            if (!simulationPaused) {
                gameLoop();
            }
        }
            
        function saveTimeStep() {
            const step = {
                time: globalTime,
                philosophers: philosophers.map(p => ({...p})),
                forks: forks.map(f => ({...f}))
            };
            timeSteps.push(step);
            currentStepIndex = timeSteps.length - 1;
        }

        function stepForward() {
            if (currentStepIndex < timeSteps.length - 1) {
                currentStepIndex++;
                applyTimeStep(timeSteps[currentStepIndex]);
            } else {
                const targetTime = globalTime + 1000;
                while (globalTime < targetTime && simulationRunning) {
                    update();
                }
                draw();
            }
            simulationPaused = true;
            document.getElementById('pauseButton').textContent = 'Resume';
        }

        function stepBackward() {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                applyTimeStep(timeSteps[currentStepIndex]);
            }
            simulationPaused = true;
            document.getElementById('pauseButton').textContent = 'Resume';
        }

        function applyTimeStep(step) {
            globalTime = step.time;
            philosophers = step.philosophers.map(p => Object.assign(new Philosopher(), p));
            forks = step.forks.map(f => Object.assign(new Fork(), f));
            draw();
        }

        // let timeSteps = [];
        // let currentStepIndex = -1;
        
        // function saveTimeStep() {
        //     const step = {
        //         time: globalTime,
        //         philosophers: philosophers.map(p => ({...p})),
        //         forks: forks.map(f => ({...f}))
        //     };
            
        //     // Remove future steps if we're not at the end
        //     if (currentStepIndex < timeSteps.length - 1) {
        //         timeSteps = timeSteps.slice(0, currentStepIndex + 1);
        //     }
            
        //     timeSteps.push(step);
        //     currentStepIndex = timeSteps.length - 1;
        // }
        
        // function stepForward() {
        //     simulationPaused = true;
        //     document.getElementById('pauseButton').textContent = 'Resume';
            
        //     const targetTime = globalTime + 1000;
            
        //     while (globalTime < targetTime) {
        //         if (currentStepIndex < timeSteps.length - 1 && timeSteps[currentStepIndex + 1].time <= targetTime) {
        //             currentStepIndex++;
        //             applyTimeStep(timeSteps[currentStepIndex]);
        //         } else {
        //             update();
        //         }
        //     }
            
        //     draw();
        // }
        
        // function stepBackward() {
        //     simulationPaused = true;
        //     document.getElementById('pauseButton').textContent = 'Resume';
            
        //     const targetTime = globalTime - 1000;
            
        //     while (currentStepIndex > 0 && timeSteps[currentStepIndex - 1].time >= targetTime) {
        //         currentStepIndex--;
        //     }
            
        //     if (currentStepIndex >= 0) {
        //         applyTimeStep(timeSteps[currentStepIndex]);
        //     }
            
        //     draw();
        // }
        
        // function applyTimeStep(step) {
        //     globalTime = step.time;
        //     philosophers = step.philosophers.map(p => Object.assign(new Philosopher(), p));
        //     forks = step.forks.map(f => Object.assign(new Fork(), f));
        // }
        
        // function update() {
        //     globalTime += 16; // Assuming 60 FPS
        //     let philosopherDied = false;
        //     philosophers.forEach(p => {
        //         if (p.update()) {
        //             philosopherDied = true;
        //         }
        //     });
        
        //     if (philosopherDied || (numMeals && philosophers.every(p => p.mealsEaten >= numMeals))) {
        //         stopSimulation();
        //     }
        
        //     saveTimeStep();
        // }
        
        function updatePrediction() {
            const predictionElement = document.getElementById('prediction');
            if (numPhilosophers === 1) {
                predictionElement.textContent = `Prediction: Philosopher will die after ${timeToDie / 1000} seconds.`;
            } else if (numPhilosophers % 2 === 0) {
                predictionElement.textContent = 'Prediction: Simulation may run forever without deaths.';
            } else {
                const worstCaseTime = (numPhilosophers - 1) * (timeToEat + timeToSleep);
                if (worstCaseTime < timeToDie) {
                    predictionElement.textContent = 'Prediction: Simulation may run forever without deaths.';
                } else {
                    predictionElement.textContent = `Prediction: A philosopher may die after ${timeToDie / 1000} seconds in the worst case.`;
                }
            }
        }

        // Initial setup
        startSimulation();
    </script>
</body>
</html>
