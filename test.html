<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dining Philosophers Visualization</title>
    <style>
        body { font-family: Arial, sans-serif; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; margin: 0; background-color: #f0f0f0; }
        #canvas { border: 1px solid #000; margin: 20px 0; }
        #info, #controls, #prediction { text-align: center; margin-bottom: 20px; }
        input, textarea { margin: 5px; padding: 5px; }
        button { margin: 10px; padding: 5px 10px; }
        #logInput { width: 80%; height: 100px; }
    </style>
</head>
<body>
    <div id="info">
        <h2>Dining Philosophers Visualization</h2>
    </div>
    <div id="controls">
        <button onclick="toggleMode()">Switch to <span id="modeText">Log</span> Mode</button>
        <div id="simulationControls">
            <input type="number" id="numPhilosophers" placeholder="Number of philosophers" min="1" value="5">
            <input type="number" id="timeToDie" placeholder="Time to die (ms)" min="1000" value="4000">
            <input type="number" id="timeToEat" placeholder="Time to eat (ms)" min="100" value="2000">
            <input type="number" id="timeToSleep" placeholder="Time to sleep (ms)" min="100" value="2000">
            <input type="number" id="numMeals" placeholder="Number of meals (optional)" min="1">
            <br>
            <button onclick="startSimulation()">Start Simulation</button>
            <button id="pauseButton" onclick="togglePause()">Pause</button>
            <button onclick="stepBackward()">-1 sec</button>
            <button onclick="stepForward()">+1 sec</button>
        </div>
        <div id="logControls" style="display: none;">
            <textarea id="logInput" placeholder="Paste your log here..."></textarea>
            <br>
            <button onclick="visualizeLog()">Visualize Log</button>
            <button onclick="stepBackward()">Previous Step</button>
            <button onclick="stepForward()">Next Step</button>
        </div>
    </div>
    <div id="prediction"></div>
    <canvas id="canvas" width="800" height="800"></canvas>
    <script>
        class Philosopher {
            constructor(id) {
                this.id = id;
                this.state = 'thinking';
                this.lastEatTime = 0;
                this.mealsEaten = 0;
            }
        }

        class Fork {
            constructor(id) {
                this.id = id;
                this.inUse = false;
                this.user = null;
            }
        }

        class Simulation {
            constructor(numPhilosophers, timeToDie, timeToEat, timeToSleep, numMeals) {
                this.numPhilosophers = numPhilosophers;
                this.timeToDie = timeToDie;
                this.timeToEat = timeToEat;
                this.timeToSleep = timeToSleep;
                this.numMeals = numMeals;
                this.philosophers = [];
                this.forks = [];
                this.time = 0;
                this.events = [];
                this.initialize();
            }

            initialize() {
                for (let i = 0; i < this.numPhilosophers; i++) {
                    this.philosophers.push(new Philosopher(i));
                    this.forks.push(new Fork(i));
                }
            }

            update(deltaTime) {
                this.time += deltaTime;
                this.philosophers.forEach((philosopher, index) => {
                    const leftFork = this.forks[index];
                    const rightFork = this.forks[(index + 1) % this.numPhilosophers];

                    switch (philosopher.state) {
                        case 'thinking':
                            if (this.time - philosopher.lastEatTime >= this.timeToDie) {
                                philosopher.state = 'dead';
                                this.addEvent(philosopher.id, 'died');
                            } else if (!leftFork.inUse && !rightFork.inUse) {
                                leftFork.inUse = rightFork.inUse = true;
                                leftFork.user = rightFork.user = philosopher;
                                philosopher.state = 'eating';
                                philosopher.lastEatTime = this.time;
                                philosopher.mealsEaten++;
                                this.addEvent(philosopher.id, 'is eating');
                            }
                            break;
                        case 'eating':
                            if (this.time - philosopher.lastEatTime >= this.timeToEat) {
                                philosopher.state = 'sleeping';
                                leftFork.inUse = rightFork.inUse = false;
                                leftFork.user = rightFork.user = null;
                                this.addEvent(philosopher.id, 'is sleeping');
                            }
                            break;
                        case 'sleeping':
                            if (this.time - philosopher.lastEatTime >= this.timeToEat + this.timeToSleep) {
                                philosopher.state = 'thinking';
                                this.addEvent(philosopher.id, 'is thinking');
                            }
                            break;
                    }
                });
            }

            addEvent(philosopherId, action) {
                this.events.push({ time: this.time, philosopherId, action });
            }

            getState() {
                return {
                    time: this.time,
                    philosophers: this.philosophers.map(p => ({ ...p })),
                    forks: this.forks.map(f => ({ ...f }))
                };
            }

            setState(state) {
                this.time = state.time;
                this.philosophers = state.philosophers.map(p => Object.assign(new Philosopher(), p));
                this.forks = state.forks.map(f => Object.assign(new Fork(), f));
            }
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let simulation;
        let simulationRunning = false;
        let simulationPaused = false;
        let animationFrameId = null;
        let lastUpdateTime;
        let isLogMode = false;
        let logSteps = [];
        let logStepIndex = -1;

        function startSimulation() {
            stopSimulation();
            
            const numPhilosophers = parseInt(document.getElementById('numPhilosophers').value) || 5;
            const timeToDie = parseInt(document.getElementById('timeToDie').value) || 4000;
            const timeToEat = parseInt(document.getElementById('timeToEat').value) || 2000;
            const timeToSleep = parseInt(document.getElementById('timeToSleep').value) || 2000;
            const numMeals = parseInt(document.getElementById('numMeals').value) || 0;

            simulation = new Simulation(numPhilosophers, timeToDie, timeToEat, timeToSleep, numMeals);
            lastUpdateTime = performance.now();
            simulationRunning = true;
            simulationPaused = false;
            updatePrediction();
            gameLoop();
            document.getElementById('pauseButton').textContent = 'Pause';
        }

        function gameLoop() {
            if (!simulationRunning || simulationPaused) return;
            
            const currentTime = performance.now();
            const deltaTime = currentTime - lastUpdateTime;
            lastUpdateTime = currentTime;

            simulation.update(deltaTime);
            draw(simulation.getState());

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function stopSimulation() {
            simulationRunning = false;
            simulationPaused = false;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        }

        function togglePause() {
            simulationPaused = !simulationPaused;
            document.getElementById('pauseButton').textContent = simulationPaused ? 'Resume' : 'Pause';
            if (!simulationPaused) {
                lastUpdateTime = performance.now();
                gameLoop();
            }
        }

        function stepForward() {
            if (isLogMode) {
                if (logStepIndex < logSteps.length - 1) {
                    logStepIndex++;
                    visualizeLogStep(logSteps[logStepIndex]);
                }
            } else {
                simulation.update(1000);  // Step forward by 1 second
                draw(simulation.getState());
            }
        }

        function stepBackward() {
            if (isLogMode) {
                if (logStepIndex > 0) {
                    logStepIndex--;
                    visualizeLogStep(logSteps[logStepIndex]);
                }
            } else {
                // For simplicity, we'll just restart the simulation and run it up to 1 second before the current time
                const currentTime = simulation.time;
                startSimulation();
                while (simulation.time < currentTime - 1000) {
                    simulation.update(16);
                }
                draw(simulation.getState());
            }
        }

        function draw(state) {
            const { philosophers, forks } = state;
            const tableRadius = Math.min(canvas.width, canvas.height) * 0.35;
            const philosopherRadius = Math.max(10, tableRadius * 0.18 - philosophers.length);
            const forkLength = Math.max(15, tableRadius * 0.22 - philosophers.length);
            const forkWidth = forkLength * 0.16;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw table
            ctx.beginPath();
            ctx.arc(canvas.width / 2, canvas.height / 2, tableRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#F0E68C';
            ctx.fill();
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 10;
            ctx.stroke();

            // Draw philosophers and forks
            philosophers.forEach((philosopher, index) => {
                const angle = (index / philosophers.length) * Math.PI * 2 - Math.PI / 2;
                const x = canvas.width / 2 + Math.cos(angle) * tableRadius;
                const y = canvas.height / 2 + Math.sin(angle) * tableRadius;

                // Draw philosopher
                ctx.beginPath();
                ctx.arc(x, y, philosopherRadius, 0, Math.PI * 2);
                ctx.fillStyle = getPhilosopherColor(philosopher.state);
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw philosopher number
                ctx.fillStyle = 'black';
                ctx.font = `bold ${Math.max(12, 24 - philosophers.length / 2)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(philosopher.id + 1, x, y);

                // Draw fork
                const forkAngle = angle + Math.PI / philosophers.length;
                const forkX = canvas.width / 2 + Math.cos(forkAngle) * tableRadius;
                const forkY = canvas.height / 2 + Math.sin(forkAngle) * tableRadius;

                ctx.save();
                ctx.translate(forkX, forkY);
                ctx.rotate(forkAngle + Math.PI / 2);
                ctx.fillStyle = forks[index].inUse ? '#E74C3C' : '#7F8C8D';
                ctx.fillRect(-forkWidth/2, -forkLength/2, forkWidth, forkLength);
                ctx.restore();
            });
        }

        function getPhilosopherColor(state) {
            switch (state) {
                case 'thinking': return '#AED6F1';
                case 'eating': return '#ABEBC6';
                case 'sleeping': return '#D7BDE2';
                default: return '#F1948A';
            }
        }

        function updatePrediction() {
            const predictionElement = document.getElementById('prediction');
            const { numPhilosophers, timeToDie, timeToEat, timeToSleep } = simulation;
            if (numPhilosophers === 1) {
                predictionElement.textContent = `Prediction: Philosopher will die after ${timeToDie / 1000} seconds.`;
            } else if (numPhilosophers % 2 === 0) {
                predictionElement.textContent = 'Prediction: Simulation may run forever without deaths.';
            } else {
                const worstCaseTime = (numPhilosophers - 1) * (timeToEat + timeToSleep);
                if (worstCaseTime < timeToDie) {
                    predictionElement.textContent = 'Prediction: Simulation may run forever without deaths.';
                } else {
                    predictionElement.textContent = `Prediction: A philosopher may die after ${timeToDie / 1000} seconds in the worst case.`;
                }
            }
        }

        function toggleMode() {
            isLogMode = !isLogMode;
            document.getElementById('modeText').textContent = isLogMode ? 'Simulation' : 'Log';
            document.getElementById('simulationControls').style.display = isLogMode ? 'none' : 'block';
            document.getElementById('logControls').style.display = isLogMode ? 'block' : 'none';
            if (isLogMode) {
                stopSimulation();
            } else {
                logSteps = [];
                logStepIndex = -1;
            }
        }

        function visualizeLog() {
            const logText = document.getElementById('logInput').value;
            const lines = logText.trim().split('\n');
            logSteps = parseLogLines(lines);
            logStepIndex = 0;
            visualizeLogStep(logSteps[0]);
        }

        function parseLogLines(lines) {
            const steps = [];
            let currentStep = null;

            lines.forEach(line => {
                const [timestamp, philosopherId, ...action] = line.split(' ');
                if (!currentStep || currentStep.timestamp !== timestamp) {
                    if (currentStep) {
                        steps.push(currentStep);
                    }
                    currentStep = { timestamp: timestamp, actions: [] };
                }
                currentStep.actions.push({ philosopherId: parseInt(philosopherId) - 1, action: action.join(' ') });
            });

            if (currentStep) {
                steps.push(currentStep);
            }

            return steps;
        }

        function visualizeLogStep(step) {
            if (!step) return;

            simulation.time = parseInt(step.timestamp) - simulation.events[0].time;
            
            step.actions.forEach(action => {
                const philosopher = simulation.philosophers[action.philosopherId];
                switch (action.action) {
                    case 'is thinking':
                        philosopher.state = 'thinking';
                        break;
                    case 'is eating':
                        philosopher.state = 'eating';
                        philosopher.mealsEaten++;
                        philosopher.lastEatTime = simulation.time;
                        break;
                    case 'is sleeping':
                        philosopher.state = 'sleeping';
                        break;
                    case 'died':
                        philosopher.state = 'dead';
                        break;
                    case 'has taken a fork':
                        // Update fork state based on philosopher's new state
                        if (philosopher.state !== 'eating') {
                            const leftFork = simulation.forks[action.philosopherId];
                            const rightFork = simulation.forks[(action.philosopherId + 1) % simulation.numPhilosophers];
                            if (!leftFork.inUse) {
                                leftFork.inUse = true;
                                leftFork.user = philosopher;
                            } else if (!rightFork.inUse) {
                                rightFork.inUse = true;
                                rightFork.user = philosopher;
                            }
                        }
                        break;
                }
            });

            draw(simulation.getState());
        }

        function initializeFromLog(logSteps) {
            if (logSteps.length === 0) return;

            const firstStep = logSteps[0];
            const numPhilosophers = Math.max(...firstStep.actions.map(a => a.philosopherId)) + 1;
            
            simulation = new Simulation(numPhilosophers, 5000, 2000, 2000, 0); // Default values, adjust as needed
            simulation.time = parseInt(firstStep.timestamp);

            visualizeLogStep(firstStep);
        }

        // Utility function to format time
        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            return `${hours.toString().padStart(2, '0')}:${(minutes % 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;
        }

        // Update the draw function to include time display
        function draw(state) {
            // ... [previous draw code] ...

            // Draw current time
            ctx.fillStyle = 'black';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`Time: ${formatTime(state.time)}`, canvas.width / 2, 30);
        }

        // Main initialization
        function init() {
            startSimulation();
            // Add event listeners for buttons if not already added
            document.getElementById('pauseButton').addEventListener('click', togglePause);
            document.querySelector('button[onclick="stepBackward()"]').addEventListener('click', stepBackward);
            document.querySelector('button[onclick="stepForward()"]').addEventListener('click', stepForward);
        }

        // Call init when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
